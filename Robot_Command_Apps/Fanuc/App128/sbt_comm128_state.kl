program comm128_stat
--***********************************************************
--
-- Copyright 2018 - 2024 speedbot All Rights reserved.
--
-- file Name: comm128_stat
--
-- Description:
--   Language             ==   Karel for FANUC ROBOT
--   Date                 ==   2022 - 02 - 26
--   Modification Data    ==   2023 - 08 - 28
--
-- Author: speedbot
--
-- Version: 3.0
--***********************************************************
--
-- 指定为系统程序，这个程序可以与其它主任务可以同步执行
%system
-- 指定程序指定时 RUNNING 灯不亮
%nobusylamp
%nopause = error + command + tpenable
%noabort = error + command
%nolockgroup
-- 不指定此参数，程序默认每 250ms 进行一次 8ms 的休眠，用以给其它更高优先级的程序处理
-- 指定为 0 时，程序会以高稳定的帧率进行执行，但是程序中必须存在 delay 或者 足够的 wait 处理
%delay = 0
%stacksize = 6000
%comment = '控制-状态'                     
%include sbt_comm128_t  
%include include/lib_socket_t
%include include/lib_busio_t
%include include/lib_buscmd_t
%include include/lib_math_t
%include include/lib_logs_t
%include kliotyps
%include sbt_comm128_global
-- %include include/lib_packages_t        --

var

    StatePackage                                : drv_stat_t
    FileVar                                     : file
    CurJointG2                                  : array[9] of real
    i                                           : integer
    Status                                      : integer
    
%include include/lib_logs_h                     -- 引用 Logs 函数库
%include include/lib_motion_h                   -- 引用 Motion 函数库
%include include/lib_string_h                   -- 引用 STRING 函数库
%include include/lib_tp_if_h                    -- 引用 示教器接口函数库
%include include/lib_socket_h
%include include/lib_math_h
%include include/lib_busio_h
%include include/lib_tcpcmd_h        --
%include include/lib_packages_h                 -- 引用数据包处理函数库

routine new_state_(SockCfg : sock_cfg_t; FileVar : file) : integer from comm128_stat

begin

    if OnlyCollect then 

        -- 设置为开机自启动时，等待网卡启动
        delay(5000)
    endif

CONNECTING::                -- 通讯链接标签, 有任何通讯错误都会跳转到这个标签

    -- 通讯链接操作
    log_info_('状态', '尝试进行网络链接 !')
    repeat  -- 开始一个无限循环，直到显式地跳出循环

        delay(TRY_CONN_TM)                          -- 等待指定的时间 TRY_CONN_TM

        tcp_close_(StatSock, FileVar)               -- 关闭 TCP 套接字（如果已打开）

        status = tcp_connect_(StatSock, FileVar)    -- 尝试建立 TCP 连接，并将连接状态存储在 status 变量中

        -- 继续循环直到连接成功
    until(status = OK)  -- 当连接状态为 OK 时跳出循环
    
    -- 进行链接后的首次握手
    -- 
    log_info_('状态', '已连接 !')
    log_info_('状态', '尝试进行握手通讯 !')
    status = new_state_(StatSock, FileVar)  -- 调用 new_state_ 函数与软件进行通讯握手，并将状态存储在 status 变量中

    if status <> OK then  -- 如果状态不是 OK

        log_error_('状态', '握手失败 !')        -- 记录错误日志：握手失败
        go to CONNECTING                        -- 跳转到 CONNECTING 标签处继续执行
    endif  -- 结束 if 语句

    log_info_('状态', '握手成功 !')
    StatePackage.DrvHead.Head = PACK_HEADER                      -- 设置包头的头部信息为常量 PACK_HEADER
    StatePackage.DrvHead.Length  = 16 + 23 * 4 + 4                -- 设置包头的长度
    StatePackage.DrvHead.PacketCount = 1                         -- 设置包头的包计数为 1
    StatePackage.DrvHead.Cmd = 255                               -- 设置包头的命令字段为 255
    StatePackage.DrvHead.Type_ = TYPE_FANUC                     -- 设置包头的类型字段为 0
    StatePackage.DrvTail = PACK_TAIL                             -- 设置包尾信息为常量 PACK_TAIL

    StatePackage.State = 0                                       -- 设置状态字段为 0
    StatePackage.NumOfRobAxis = NumOfRobAxis                     -- 设置机器人轴的数量
    StatePackage.NumOfRotAxis = NumOfRotAxis                     -- 设置旋转轴的数量
    StatePackage.Reserverd1 = 0                                  -- 设置保留字段为 0

    -- 实时状态数据初始化
    StatePackage.MoveId = 0                                      -- 设置移动 ID 为 0
    for i = 1 to 8 do StatePackage.DinVal[i] = 0; endfor         -- 初始化数字输入值数组为 0
    for i = 1 to 13 do StatePackage.Joints[i] = 0.0; endfor      -- 初始化关节坐标数组为 0.0
    StatePackage.ProcessPrm01 = 0.0                              -- 初始化过程参数 1 为 0.0
    StatePackage.ProcessPrm02 = 0.0                              -- 初始化过程参数 2 为 0.0
    StatePackage.ProcessPrm03 = 0.0                              -- 初始化过程参数 3 为 0.0
    StatePackage.ProcessPrm04 = 0.0                              -- 初始化过程参数 4 为 0.0
    StatePackage.ProcessPrm05 = 0.0                              -- 初始化过程参数 5 为 0.0
    StatePackage.ProcessPrm06 = 0.0                              -- 初始化过程参数 6 为 0.0

    Restart = false

    while (status = OK) and (not Restart) do  -- 当状态为 OK 时持续执行循环

        StatePackage.State = 0  -- 将状态字段初始化为 0

        -- 报文 ID 累加
        StatePackage.DrvHead.Seq = tern_int_(StatePackage.DrvHead.Seq < 255, StatePackage.DrvHead.Seq + 1, 1)  -- 如果序列号小于 255，则加 1；否则，设置为 1

        if not OnlyCollect then  -- 如果不是仅收集数据模式

            -- 非数采模式时，采集允许控制状态
            if is_ready_ and (tp_running_) or (tp_pause_) then
                StatePackage.State = StatePackage.State or 1  -- 如果准备好并且正在运行，则设置状态的第一位为 1
            endif
        endif

        -- 暂停中 ?
        if tp_pause_ then
            StatePackage.State = StatePackage.State or 2  -- 如果暂停，则设置状态的第二位为 1
        endif

        -- 错误中 ?
        if tp_fault_ then
            StatePackage.State = StatePackage.State or 4  -- 如果有错误，则设置状态的第三位为 1
        endif

        -- 移动中
        if is_moving_ then
            StatePackage.State = StatePackage.State or 8  -- 如果正在移动，则设置状态的第四位为 1
        endif

        -- 运动 ID
        StatePackage.MoveId = get_ireg_(REG_MOV_ID)  -- 获取运动 ID

        -- DIN 信号状态
        StatePackage.DinVal[1] = bus_gbyte_(IO_DIN, IoMap.InAddr1)  -- 获取 DIN 信号状态 1
        StatePackage.DinVal[2] = bus_gbyte_(IO_DIN, IoMap.InAddr2)  -- 获取 DIN 信号状态 2
        StatePackage.DinVal[3] = bus_gbyte_(IO_DIN, IoMap.InAddr3)  -- 获取 DIN 信号状态 3
        StatePackage.DinVal[4] = bus_gbyte_(IO_DIN, IoMap.InAddr4)  -- 获取 DIN 信号状态 4
        StatePackage.DinVal[5] = bus_gbyte_(IO_DIN, IoMap.InAddr5)  -- 获取 DIN 信号状态 5
        StatePackage.DinVal[6] = bus_gbyte_(IO_DIN, IoMap.InAddr6)  -- 获取 DIN 信号状态 6
        StatePackage.DinVal[7] = bus_gbyte_(IO_DIN, IoMap.InAddr7)  -- 获取 DIN 信号状态 7
        StatePackage.DinVal[8] = bus_gbyte_(IO_DIN, IoMap.InAddr8)  -- 获取 DIN 信号状态 8

        -- 获取当前组一关节位置
        decom_axis2_(c_mulgp_jps_(1), StatePackage.Joints)  -- 获取当前组一的关节位置


        -- 存在组二信息，则采集组二的关节位置
        if StatePackage.NumOfRotAxis > 0 then  -- 如果存在旋转轴

            decom_axis2_(c_mulgp_jps_(2), CurJointG2)  -- 获取组二的关节位置
            for i = 1 to StatePackage.NumOfRotAxis do
                StatePackage.Joints[StatePackage.NumOfRobAxis + i] = CurJointG2[i] -- / 180.0 * PI  -- 将组二的关节位置添加到状态包中
            endfor 
        endif

        -- 发送报文头
        status = spack_head_(StatSock, FileVar, StatePackage.DrvHead)  -- 发送报文头信息

        -- 发送实时状态数据
        write FileVar(  chr((StatePackage.State))::1, &
                        chr((StatePackage.NumOfRobAxis))::1, &
                        chr((StatePackage.NumOfRotAxis))::1, &
                        chr((StatePackage.Reserverd1))::1, &
                        StatePackage.MoveId)

        for i = 1 to 8 do
            write FileVar(chr((StatePackage.DinVal[i]))::1)  -- 写入 DIN 信号状态
        endfor

        for i = 1 to 13 do
            write FileVar(StatePackage.Joints[i])  -- 写入关节位置
        endfor

        write FileVar(StatePackage.ProcessPrm01)  -- 写入过程参数 1
        write FileVar(StatePackage.ProcessPrm02)  -- 写入过程参数 2
        write FileVar(StatePackage.ProcessPrm03)  -- 写入过程参数 3
        write FileVar(StatePackage.ProcessPrm04)  -- 写入过程参数 4
        write FileVar(StatePackage.ProcessPrm05)  -- 写入过程参数 5
        write FileVar(StatePackage.ProcessPrm06)  -- 写入过程参数 6

        -- 发送报文尾
        status = spack_tail_(StatSock, FileVar, StatePackage.DrvTail)  -- 发送报文尾信息

        -- 休眠指定的时间
        -- 不能注释，也不能为 0，否则将会占用所有的 CPU ，导致机器人死机
        delay(round(1000.0 / StateFreq))  -- 休眠指定的时间
    endwhile

    log_error_('状态', '通讯断开 !')

    go to CONNECTING

end comm128_stat

routine new_state_
var
    CurTimer            : integer  -- 当前定时器值
    Size                : integer  -- 接收缓冲区中的字节数
    Status              : integer  -- 状态变量
    WriteAck            : integer  -- 写确认标志
    Packages1           : drv_ack_t
    Packages2           : drv_ack_t
begin
    Packages1.DrvHead.Head = PACK_HEADER        -- 设置包头的头部信息为常量 PACK_HEADER
    Packages1.DrvHead.Length  = 24               -- 设置包头的长度为 24
    Packages1.DrvHead.PacketCount = 1           -- 设置包头的包计数为 1
    Packages1.DrvHead.Cmd = 254                 -- 设置包头的命令字段为 0
    Packages1.DrvHead.Type_ = TYPE_FANUC        -- 设置包头的类型字段为 机器人品牌
    Packages1.DrvHead.Seq = 1                   -- 设置包头的序列号为 1
    Packages1.DrvHead.VirtualRob = IsVirRobId   -- 设置虚拟机器人 ID
    WriteAck = 0                                -- 设置写确认标志为 0
    Packages1.DrvTail = PACK_TAIL              

    Packages2.DrvHead.Head = 0                  -- 清空包头的头部信息
    Packages2.DrvHead.Length  = 0                -- 清空包头的长度
    Packages2.DrvHead.PacketCount = 0           -- 清空包头的包计数
    Packages2.DrvHead.Cmd = 0                   -- 清空包头的命令字段
    Packages2.DrvHead.Type_ = 0                 -- 清空包头的类型字段
    Packages2.DrvHead.Seq = 0                   -- 清空包头的序列号
    Packages2.DrvHead.VirtualRob = 0            -- 清空虚拟机器人 ID
    Packages2.Ack = 0                           -- 清空确认标志
    Packages2.DrvTail = 0                       -- 清空包尾信息

    status = spack_head_(SockCfg, fileVar, Packages1.DrvHead)  -- 发送报文头
    if status <> OK then
        return(status)  -- 如果发送失败，返回状态
    endif

    write fileVar(WriteAck)             -- 写入写确认标志
    status = io_status(fileVar)         -- 获取 I/O 状态
    if status <> OK then
        clr_io_stat(fileVar)            -- 清除 I/O 状态
        return(status)                  -- 返回状态
    endif

    status = spack_tail_(SockCfg, fileVar, Packages1.DrvTail)  -- 发送报文尾
    if status <> OK then
        return(status)  -- 如果发送失败，返回状态
    endif

    CurTimer = $fast_clock  -- 获取当前定时器值

    repeat  -- 开始无限循环
        bytes_ahead(fileVar, Size, status)      -- 获取接收缓冲区中的字节数
        if status <> OK then
            return(-abs(status))                -- 如果获取失败，返回负的绝对值状态
        endif

        if Size >= Packages1.DrvHead.Length  then  -- 如果接收缓冲区中的字节数大于等于预期长度

            status = rpack_head_(SockCfg, fileVar, Packages2.DrvHead)  -- 读取报文头
            if status <> OK then
                return(status)  -- 如果读取失败，返回状态
            endif

            read fileVar(Packages2.Ack)         -- 读取确认标志
            status = io_status(fileVar)         -- 获取 I/O 状态
            if status <> OK then
                clr_io_stat(fileVar)            -- 清除 I/O 状态
                return(status)                  -- 返回状态
            endif

            status = rpack_tail_(SockCfg, fileVar, Packages2.DrvTail)  -- 读取报文尾
            if status <> OK then
                return(status)  -- 如果读取失败，返回状态
            endif

            if Packages2.DrvHead.Cmd <> 254 then  -- 如果类型字段不为 1
                return(NG)  -- 返回错误状态
            endif

            return(OK)  -- 返回成功状态
        endif

        if $fast_clock - CurTimer >= SHAKE_TIME then    -- 如果超时
            return(NG)  -- 返回错误状态
        endif

        delay(100)  -- 等待 100 毫秒
    until false  -- 结束无限循环

    return(OK)  -- 返回成功状态
end new_state_
