program Sbtheadctrl
--***********************************************************
--
-- file Name: Sbtheadctrl
--
-- Description:
--   Language             ==   Karel for FANUC ROBOT
--   Date                 ==   2025 - 07 - 30
--   Modification Data    ==   2025 - 07 - 30
--
-- Author: 
--
-- Version: 1.0
%comment = 'SBT HEAD CTRL 250730'
%nolockgroup
%system
%nobusylamp 
%nopauseshft

%include kliotyps
%include klevccdf
%include include/lib_socket_t
%include include/lib_logs_t
%include include/lib_transform_t
%include include/lib_busio_t
%include include/lib_math_t
%include sbt_comm12_t
%include sbt_comm12_global

%include include/lib_tp_if_h
%include include/lib_string_h
%include include/lib_busio_h
%include include/lib_math_h

routine HeadStarting(GrindHeadId : integer; Speed : real; TimeOut : integer) from Sbtheadctrl
routine HeadStoping(GrindHeadId : integer) from Sbtheadctrl
routine HeadRelease(GrindHeadId : integer; TimeOut : integer) from Sbtheadctrl
routine HeadClamp(GrindHeadId : integer; TimeOut : integer) from Sbtheadctrl
routine DoorOpen(GrindHeadId : integer; TimeOut : integer) from Sbtheadctrl
routine DoorClose(GrindHeadId : integer; TimeOut : integer) from Sbtheadctrl
routine KeyHeadStart(GrindHeadId : integer) from Sbtheadctrl
routine keyheadstop(GrindHeadId : integer) from Sbtheadctrl
routine KeyHeadRelea(GrindHeadId : integer) from Sbtheadctrl
routine KeyHeadClamp(GrindHeadId : integer) from Sbtheadctrl
routine KeyDoorOpen(GrindHeadId : integer) from Sbtheadctrl
routine KeyDoorClose(GrindHeadId : integer) from Sbtheadctrl
routine KeySelecFunc : integer from Sbtheadctrl
routine KeySelecHead : integer from Sbtheadctrl
routine HeadStatus(GrindHeadId : integer) from Sbtheadctrl
routine CheckHeadId(GrindHeadId : integer) from Sbtheadctrl
routine CheckHeadAlm(GrindHeadId : integer) from Sbtheadctrl
routine GetGiHeadErr(GrindHeadId : integer) : integer from Sbtheadctrl
routine SetGoHedSped(GrindHeadId : integer; Speed : integer) from Sbtheadctrl
routine GetGoHedSped(GrindHeadId : integer) : integer from Sbtheadctrl
routine GrindResume from Sbtheadctrl
routine GrindAlarm from Sbtheadctrl
routine IntrHedResum from Sbtheadctrl
routine IntrHedAlarm from Sbtheadctrl

begin 
    
end Sbtheadctrl

routine HeadStarting
var
    TimerIndex                  : integer
begin
    if not(GrindHeadTol[GrindHeadId].HeadEnable) then 
        GrindInform.CurGrindId = 0
        return
    endif 
    HeadStatus(GrindHeadId)

    SetGoHedSped(GrindHeadId, round(Speed * 10))

    if dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART] then
        return
    endif 

    delay 12
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART] = true 
    delay 100

    repeat

        TimerIndex = $fast_clock
        
        if TimeOut > 0 then 
            repeat
                delay WAIT_CYCTIME
            until((din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADSTART]) or (($fast_clock - TimerIndex) > TimeOut))
        else 
            wait for (din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADSTART])
        endif

        if not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADSTART]) then 
            post_err(CC_UALARM, '启动打磨头[ID:' + int_to_str_(GrindHeadId) + ']超时', 0, CC_PAUSE)
        endif 
        
    until(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADSTART])

    GrindInform.CurGrindId = GrindHeadId
end HeadStarting

routine HeadStoping
begin
    if not(GrindHeadTol[GrindHeadId].HeadEnable) then 
        return
    endif 

    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART] = false

    SetGoHedSped(GrindHeadId, 0)
end HeadStoping

routine HeadRelease
var
    TimerIndex                  : integer
begin
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADCLAMP] = false
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADRELEAS] = true

    repeat

        TimerIndex = $fast_clock

        if TimeOut > 0 then 
            repeat
                delay WAIT_CYCTIME
            until(((din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP])) or (($fast_clock - TimerIndex) > TimeOut))
        else 
            repeat
                delay WAIT_CYCTIME
            until((din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP]))
        endif

        if not((din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP])) then 
            post_err(CC_UALARM, '松开打磨头[ID:' + int_to_str_(GrindHeadId) + ']超时', 0, CC_PAUSE)
        endif 
        
    until((din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP]))
end HeadRelease

routine HeadClamp
var
    TimerIndex                  : integer
begin
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADRELEAS] = false
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADCLAMP] = true

    repeat

        TimerIndex = $fast_clock

        if TimeOut > 0 then 
            repeat
                delay WAIT_CYCTIME
            until((not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP])) or (($fast_clock - TimerIndex) > TimeOut))
        else 
            repeat
                delay WAIT_CYCTIME
            until(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP]))
        endif

        if not(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP])) then 
            post_err(CC_UALARM, '夹紧打磨头[ID:' + int_to_str_(GrindHeadId) + ']超时', 0, CC_PAUSE)
        endif 
        
    until(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADRELEAS]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_HEADCLAMP]))
end HeadClamp

routine DoorOpen
var
    TimerIndex                  : integer
begin
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOORCLOSE] = false
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOOROPEN] = true

    repeat

        TimerIndex = $fast_clock

        if TimeOut > 0 then 
            repeat
                delay WAIT_CYCTIME
            until((not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN])) or (($fast_clock - TimerIndex) > TimeOut))
        else 
            repeat
                delay WAIT_CYCTIME
            until(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN]))
        endif

        if not(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN])) then 
            post_err(CC_UALARM, '夹紧打磨头[ID:' + int_to_str_(GrindHeadId) + ']超时', 0, CC_PAUSE)
        endif 
        
    until(not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and (din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN]))
end DoorOpen

routine DoorClose
var
    TimerIndex                  : integer
begin
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOORCLOSE] = true
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOOROPEN] = false

    repeat

        TimerIndex = $fast_clock

        if TimeOut > 0 then 
            repeat
                delay WAIT_CYCTIME
            until(((din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN])) or (($fast_clock - TimerIndex) > TimeOut))
        else 
            repeat
                delay WAIT_CYCTIME
            until((din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN]))
        endif

        if not((din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN])) then 
            post_err(CC_UALARM, '松开打磨头[ID:' + int_to_str_(GrindHeadId) + ']超时', 0, CC_PAUSE)
        endif 
        
    until((din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOORCLOSE]) and not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_DOOROPEN]))
end DoorClose

routine KeyHeadStart
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif 

    if din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY] then 

        if not(dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART]) then 
            SetGoHedSped(GrindHeadId, round(ManuGrinSped[GrindHeadId]) * 10)
            dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART] = true

            post_err(CC_UALARM, '手动打磨启动[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
        else 
            
            if (GetGoHedSped(GrindHeadId) / 10.0 + 50) >= GrindHeadTol[GrindHeadId].MaxGrindSped then
                SetGoHedSped(GrindHeadId, round(GrindHeadTol[GrindHeadId].MaxGrindSped * 10))
            else
                SetGoHedSped(GrindHeadId, round((GetGoHedSped(GrindHeadId) / 10.0 + 50) * 10))
            endif
        endif 
    else
        post_err(CC_UALARM, '打磨头没有准备就绪[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
    endif 
end KeyHeadStart

routine keyheadstop
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif
    
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSTART] = false
    SetGoHedSped(GrindHeadId, 0)

    post_err(CC_UALARM, '手动打磨头停止[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
end keyheadstop

routine KeyHeadRelea
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif

    if din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY] then 
        
        dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADCLAMP] = false
        dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADRELEAS] = true

        post_err(CC_UALARM, '手动打磨头松开[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
    else
        post_err(CC_UALARM, '打磨头没有准备就绪[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
    endif 
end KeyHeadRelea

routine KeyHeadClamp
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif

    if din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY] then 
        
        dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADRELEAS] = false
        dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADCLAMP] = true

        post_err(CC_UALARM, '手动打磨头夹紧[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
    else
        post_err(CC_UALARM, '打磨头没有准备就绪[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
    endif 
end KeyHeadClamp

routine KeyDoorOpen
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif

    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOORCLOSE] = false
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOOROPEN] = true

    post_err(CC_UALARM, '手动打磨头打开[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
end KeyDoorOpen

routine KeyDoorClose
begin
    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ', Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif

    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOOROPEN] = false
    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_DOORCLOSE] = true

    post_err(CC_UALARM, '手动打磨头关闭[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
end KeyDoorClose

routine KeySelecFunc
var
    ModeKey                 : integer
begin
    repeat
        force_spmenu(TP_PANEL, SPI_TPUSER, 1)
        write tpdisplay(chr(137), chr(128))
        write tpdisplay('选择手动操作打磨头的功能', cr)
        write tpdisplay('1.启动打磨头', cr)
        write tpdisplay('2.停止打磨头', cr)
        write tpdisplay('3.松开打磨头', cr)
        write tpdisplay('4.夹紧打磨头', cr)
        write tpdisplay('5.打开打磨头', cr)
        write tpdisplay('6.关闭打磨头', cr)
        read tpdisplay(ModeKey)
    until((ModeKey >= 1) and (ModeKey <= 6))
    return(ModeKey)
end KeySelecFunc

routine KeySelecHead
var
    ModeKey                 : integer
begin
    repeat
        force_spmenu(TP_PANEL, SPI_TPUSER, 1)
        write tpdisplay(chr(137), chr(128))
        write tpdisplay('输入需要操作的打磨头ID(1-' + (int_to_str_(MAX_GRINDNUM)) + ')', cr)
        read tpdisplay(ModeKey)
    until((ModeKey >= 1) and (ModeKey <= MAX_GRINDNUM))
    return(ModeKey)
end KeySelecHead

routine HeadStatus
begin
    if not(GrindHeadTol[GrindHeadId].HeadEnable) then 
        return
    endif 

    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

    if (GrindHeadTol[GrindHeadId].DoutputAddr <= 0) or (GrindHeadTol[GrindHeadId].DoutputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输出地址[ID:' + int_to_str_(GrindHeadId) + ',Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif 

    if (GrindHeadTol[GrindHeadId].DinputAddr <= 0) or (GrindHeadTol[GrindHeadId].DinputAddr >= $max_dig_prt) then 
        post_err(CC_UALARM, '无效信号输入地址[ID:' + int_to_str_(GrindHeadId) + 'Addr:' + int_to_str_(GrindHeadTol[GrindHeadId].DoutputAddr) + ']', 0, CC_ABORT)
    endif 

    CheckHeadId(GrindHeadId)

    CheckHeadAlm(GrindHeadId)

    dout[GrindHeadTol[GrindHeadId].DoutputAddr + O_ENABLE] = true

    if not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY]) then 
        post_err(CC_UALARM, '等待打磨头准备就绪[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
        
        wait for (din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY])
    endif
end HeadStatus

routine CheckHeadId
begin
    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

    if (GrindHeadTol[GrindHeadId].BindToolNum <= 0) or (GrindHeadTol[GrindHeadId].BindToolNum >= $scr.$maxnumutool) then 
        post_err(CC_UALARM, '无效工具号[ID:' + int_to_str_(GrindHeadId) + ',Tool:' + int_to_str_(GrindHeadTol[GrindHeadId].BindToolNum) + ']', 0, CC_ABORT)
    endif 

    post_err(CC_UALARM, '打磨头对应工具[ID:' + int_to_str_(GrindHeadId) + ',Tool:' + int_to_str_(GrindHeadTol[GrindHeadId].BindToolNum) + ']', 0, CC_WARN)
end CheckHeadId

routine CheckHeadAlm
begin
    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

    if not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY]) then 
        post_err(CC_UALARM, '等待打磨头准备就绪[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_WARN)
    endif
    repeat
        GrindHeadTol[GrindHeadId].ErrorId = GetGiHeadErr(GrindHeadId)

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E01] then 
            post_err(CC_UALARM, GrindErrMsg[1] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif 

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E02] then 
            post_err(CC_UALARM, GrindErrMsg[2] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E03] then 
            post_err(CC_UALARM, GrindErrMsg[3] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E04] then 
            post_err(CC_UALARM, GrindErrMsg[4] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E05] then 
            post_err(CC_UALARM, GrindErrMsg[5] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E06] then 
            post_err(CC_UALARM, GrindErrMsg[6] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E07] then 
            post_err(CC_UALARM, GrindErrMsg[7] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E08] then 
            post_err(CC_UALARM, GrindErrMsg[8] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E09] then 
            post_err(CC_UALARM, GrindErrMsg[9] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E10] then 
            post_err(CC_UALARM, GrindErrMsg[10] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E11] then 
            post_err(CC_UALARM, GrindErrMsg[11] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E12] then 
            post_err(CC_UALARM, GrindErrMsg[12] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E13] then 
            post_err(CC_UALARM, GrindErrMsg[13] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E14] then 
            post_err(CC_UALARM, GrindErrMsg[14] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E15] then 
            post_err(CC_UALARM, GrindErrMsg[15] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if din[GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E16] then 
            post_err(CC_UALARM, GrindErrMsg[16] + '[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_PAUSE)
        endif

        if not(din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY]) then 
            delay WAIT_CYCTIME
        endif 
        
    until(din[GrindHeadTol[GrindHeadId].DinputAddr + I_READY])
end CheckHeadAlm

routine GetGiHeadErr
begin
    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效的打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

    return(bus_gusint_(IO_DIN, GrindHeadTol[GrindHeadId].DinputAddr + I_ERR_E01))
end GetGiHeadErr

routine SetGoHedSped
begin
    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

    bus_susint_(GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSPEED, Speed)

    GrindInform.CurGrindsped = Speed / 10.0
end SetGoHedSped

routine GetGoHedSped
begin
    if (GrindHeadId <= 0) or (GrindHeadId > MAX_GRINDNUM) then 
        post_err(CC_UALARM, '无效打磨头[ID:' + int_to_str_(GrindHeadId) + ']', 0, CC_ABORT)
    endif 

   GrindInform.CurGrindsped = bus_gusint_(IO_DOUT, GrindHeadTol[GrindHeadId].DoutputAddr + O_HEADSPEED) / 10
   return(round(GrindInform.CurGrindsped * 10))
end GetGoHedSped

routine GrindResume
var
    Status                  : boolean
begin
    stop
    delay 500
    if GrindHeadTol[GrindInform.CurGrindId].HeadEnable then 
        HeadStarting(GrindInform.CurGrindId, GrindInform.CurGrindsped, 5000)
    endif 
    resume
    enable condition[INTR_RESUM]
end GrindResume

routine GrindAlarm
begin
    dout[GrindHeadTol[GrindInform.CurGrindId].DoutputAddr + O_HEADSTART] = false
    stop
    delay 500
    CheckHeadAlm(GrindInform.CurGrindId)
    HeadStarting(GrindInform.CurGrindId, GrindInform.CurGrindsped, 5000)
    resume
    enable condition[INTR_ALARM]
end GrindAlarm

routine IntrHedResum
begin
    condition[INTR_RESUM]: with $scan_time = 20
        when opout[1]+ do
            GrindResume                
    endcondition
    enable condition[INTR_RESUM]  
end IntrHedResum

routine IntrHedAlarm
begin
    condition[INTR_ALARM]: with $scan_time = 20
        when din[GrindHeadTol[GrindInform.CurGrindId].DinputAddr + I_READY] = false do  
            GrindAlarm                
    endcondition
    enable condition[INTR_ALARM]  
end IntrHedAlarm